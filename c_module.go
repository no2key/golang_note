/*run c(prog language) module*/

package bridge

// #cgo CFLAGS: -Wall        - флаги компилятора
// #cgo LDFLAGS: -              - флаги линковшика
// #include <stdio.h>

или
/*
#cgo CFLAGS: -Wall       
#cgo LDFLAGS: -              
#include <stdio.h>
*/

import(
"fmt"
)

func main() {

  var x C.int
	var arr [4]C.int
	var p_arr *C.byte
	p_arr = &arr[0]

	for i, _ := range arr {
		arr[i] = 10
	}

	C.init_crypt()

	x = 10
	fmt.Println(x)
	fmt.Println(arr)
	fmt.Println(*p_arr, p_arr)
}




********************************************************
*****************************************************
КОД ШИРОВАНИЯ ГОСТ89
******************************************************
package main

/*
#cgo CFLAGS: -Werror
#ifndef GOST89_H
#define GOST89_H

typedef unsigned int u4;
typedef unsigned int word32;

typedef unsigned char byte;

typedef struct {
		byte k8[16];
		byte k7[16];
		byte k6[16];
		byte k5[16];
		byte k4[16];
		byte k3[16];
		byte k2[16];
		byte k1[16];
} gost_subst_block;

typedef struct {
		u4 k[8];
		u4 k87[256],k65[256],k43[256],k21[256];
} gost_ctx;

void gostcrypt(gost_ctx *c, byte *inout);

void gostdecrypt(gost_ctx *c, byte *inout);

void gost_enc_cfb(gost_ctx *c, const byte *initvector, byte *cipher_buf, int nbytes);
void gost_dec_cfb(gost_ctx *c, const byte *initvector, byte *cipher_buf, int nbytes);

void gost_key(gost_ctx *ctx, const byte *key);

void gost_init(gost_ctx *c, const byte *key, const gost_subst_block *b);

extern gost_subst_block GostR3411_94_TestParamSet;
extern gost_subst_block GostR3411_94_CryptoProParamSet;
extern gost_subst_block Gost28147_TestParamSet;
extern gost_subst_block Gost28147_CryptoProParamSetA;
extern gost_subst_block Gost28147_CryptoProParamSetB;
extern gost_subst_block Gost28147_CryptoProParamSetC;
extern gost_subst_block Gost28147_CryptoProParamSetD;
extern gost_subst_block GostR3411_94_SberbankHashParamset;

#endif

gost_subst_block GostR3411_94_TestParamSet = {
  {0X1,0XF,0XD,0X0,0X5,0X7,0XA,0X4,0X9,0X2,0X3,0XE,0X6,0XB,0X8,0XC},
  {0XD,0XB,0X4,0X1,0X3,0XF,0X5,0X9,0X0,0XA,0XE,0X7,0X6,0X8,0X2,0XC},
  {0X4,0XB,0XA,0X0,0X7,0X2,0X1,0XD,0X3,0X6,0X8,0X5,0X9,0XC,0XF,0XE},
  {0X6,0XC,0X7,0X1,0X5,0XF,0XD,0X8,0X4,0XA,0X9,0XE,0X0,0X3,0XB,0X2},
  {0X7,0XD,0XA,0X1,0X0,0X8,0X9,0XF,0XE,0X4,0X6,0XC,0XB,0X2,0X5,0X3},
  {0X5,0X8,0X1,0XD,0XA,0X3,0X4,0X2,0XE,0XF,0XC,0X7,0X6,0X0,0X9,0XB},
  {0XE,0XB,0X4,0XC,0X6,0XD,0XF,0XA,0X2,0X3,0X8,0X1,0X0,0X7,0X5,0X9},
  {0X4,0XA,0X9,0X2,0XD,0X8,0X0,0XE,0X6,0XB,0X1,0XC,0X7,0XF,0X5,0X3}
};

gost_subst_block GostR3411_94_CryptoProParamSet= {
  {0x1,0x3,0xA,0x9,0x5,0xB,0x4,0xF,0x8,0x6,0x7,0xE,0xD,0x0,0x2,0xC},
  {0xD,0xE,0x4,0x1,0x7,0x0,0x5,0xA,0x3,0xC,0x8,0xF,0x6,0x2,0x9,0xB},
  {0x7,0x6,0x2,0x4,0xD,0x9,0xF,0x0,0xA,0x1,0x5,0xB,0x8,0xE,0xC,0x3},
  {0x7,0x6,0x4,0xB,0x9,0xC,0x2,0xA,0x1,0x8,0x0,0xE,0xF,0xD,0x3,0x5},
  {0x4,0xA,0x7,0xC,0x0,0xF,0x2,0x8,0xE,0x1,0x6,0x5,0xD,0xB,0x9,0x3},
  {0x7,0xF,0xC,0xE,0x9,0x4,0x1,0x0,0x3,0xB,0x5,0x2,0x6,0xA,0x8,0xD},
  {0x5,0xF,0x4,0x0,0x2,0xD,0xB,0x9,0x1,0x7,0x6,0x3,0xC,0xE,0xA,0x8},
  {0xA,0x4,0x5,0x6,0x8,0x1,0x3,0x7,0xD,0xC,0xE,0x0,0x9,0x2,0xB,0xF}
} ;

gost_subst_block GostR3411_94_SberbankHashParamset={
{0x3,0x6,0xA,0xe,0x2,0xb,0x1,0x9,0xd,0xc,0x8,0xf,0x4,0x5,0x0,0x7},
{0x9,0x4,0x0,0xf,0x7,0xd,0xa,0xb,0x2,0x3,0x5,0x6,0xe,0x1,0xc,0x8},
{0x3,0x9,0x4,0x0,0xe,0x7,0x8,0xf,0x5,0xd,0x6,0xa,0xb,0x2,0x1,0xc},
{0x5,0x3,0xf,0xe,0xa,0x0,0xb,0x8,0x7,0x1,0xd,0x9,0x2,0x4,0xc,0x6},
{0xa,0xc,0xb,0x0,0x6,0x2,0xe,0x8,0xf,0x5,0x7,0xd,0x3,0x9,0x4,0x1},
{0xa,0x5,0xc,0x8,0xd,0x2,0x1,0x9,0xb,0x7,0xe,0xf,0x0,0x3,0x6,0x4},
{0xc,0x8,0x9,0xd,0x3,0x4,0x1,0x5,0x7,0x6,0x2,0xf,0xa,0x0,0xb,0xe},
{0x8,0x7,0x3,0xc,0xe,0xd,0x2,0x0,0xb,0xa,0x4,0x1,0x5,0xf,0x9,0x6},
};

gost_subst_block Gost28147_TestParamSet =
{
	{0xC,0x6,0x5,0x2,0xB,0x0,0x9,0xD,0x3,0xE,0x7,0xA,0xF,0x4,0x1,0x8},
	{0x9,0xB,0xC,0x0,0x3,0x6,0x7,0x5,0x4,0x8,0xE,0xF,0x1,0xA,0x2,0xD},
	{0x8,0xF,0x6,0xB,0x1,0x9,0xC,0x5,0xD,0x3,0x7,0xA,0x0,0xE,0x2,0x4},
	{0x3,0xE,0x5,0x9,0x6,0x8,0x0,0xD,0xA,0xB,0x7,0xC,0x2,0x1,0xF,0x4},
	{0xE,0x9,0xB,0x2,0x5,0xF,0x7,0x1,0x0,0xD,0xC,0x6,0xA,0x4,0x3,0x8},
	{0xD,0x8,0xE,0xC,0x7,0x3,0x9,0xA,0x1,0x5,0x2,0x4,0x6,0xF,0x0,0xB},
	{0xC,0x9,0xF,0xE,0x8,0x1,0x3,0xA,0x2,0x7,0x4,0xD,0x6,0x0,0xB,0x5},
	{0x4,0x2,0xF,0x5,0x9,0x1,0x0,0x8,0xE,0x3,0xB,0xC,0xD,0x7,0xA,0x6}
};

gost_subst_block Gost28147_CryptoProParamSetA= {
	{0xB,0xA,0xF,0x5,0x0,0xC,0xE,0x8,0x6,0x2,0x3,0x9,0x1,0x7,0xD,0x4},
	{0x1,0xD,0x2,0x9,0x7,0xA,0x6,0x0,0x8,0xC,0x4,0x5,0xF,0x3,0xB,0xE},
	{0x3,0xA,0xD,0xC,0x1,0x2,0x0,0xB,0x7,0x5,0x9,0x4,0x8,0xF,0xE,0x6},
	{0xB,0x5,0x1,0x9,0x8,0xD,0xF,0x0,0xE,0x4,0x2,0x3,0xC,0x7,0xA,0x6},
	{0xE,0x7,0xA,0xC,0xD,0x1,0x3,0x9,0x0,0x2,0xB,0x4,0xF,0x8,0x5,0x6},
	{0xE,0x4,0x6,0x2,0xB,0x3,0xD,0x8,0xC,0xF,0x5,0xA,0x0,0x7,0x1,0x9},
	{0x3,0x7,0xE,0x9,0x8,0xA,0xF,0x0,0x5,0x2,0x6,0xC,0xB,0x4,0xD,0x1},
	{0x9,0x6,0x3,0x2,0x8,0xB,0x1,0x7,0xA,0x4,0xE,0xF,0xC,0x0,0xD,0x5}
};

gost_subst_block Gost28147_CryptoProParamSetB=
{
	{0x0,0x4,0xB,0xE,0x8,0x3,0x7,0x1,0xA,0x2,0x9,0x6,0xF,0xD,0x5,0xC},
	{0x5,0x2,0xA,0xB,0x9,0x1,0xC,0x3,0x7,0x4,0xD,0x0,0x6,0xF,0x8,0xE},
	{0x8,0x3,0x2,0x6,0x4,0xD,0xE,0xB,0xC,0x1,0x7,0xF,0xA,0x0,0x9,0x5},
	{0x2,0x7,0xC,0xF,0x9,0x5,0xA,0xB,0x1,0x4,0x0,0xD,0x6,0x8,0xE,0x3},
	{0x7,0x5,0x0,0xD,0xB,0x6,0x1,0x2,0x3,0xA,0xC,0xF,0x4,0xE,0x9,0x8},
	{0xE,0xC,0x0,0xA,0x9,0x2,0xD,0xB,0x7,0x5,0x8,0xF,0x3,0x6,0x1,0x4},
	{0x0,0x1,0x2,0xA,0x4,0xD,0x5,0xC,0x9,0x7,0x3,0xF,0xB,0x8,0x6,0xE},
	{0x8,0x4,0xB,0x1,0x3,0x5,0x0,0x9,0x2,0xE,0xA,0xC,0xD,0x6,0x7,0xF}
};

gost_subst_block Gost28147_CryptoProParamSetC=
{
	{0x7,0x4,0x0,0x5,0xA,0x2,0xF,0xE,0xC,0x6,0x1,0xB,0xD,0x9,0x3,0x8},
	{0xA,0x9,0x6,0x8,0xD,0xE,0x2,0x0,0xF,0x3,0x5,0xB,0x4,0x1,0xC,0x7},
	{0xC,0x9,0xB,0x1,0x8,0xE,0x2,0x4,0x7,0x3,0x6,0x5,0xA,0x0,0xF,0xD},
	{0x8,0xD,0xB,0x0,0x4,0x5,0x1,0x2,0x9,0x3,0xC,0xE,0x6,0xF,0xA,0x7},
	{0x3,0x6,0x0,0x1,0x5,0xD,0xA,0x8,0xB,0x2,0x9,0x7,0xE,0xF,0xC,0x4},
	{0x8,0x2,0x5,0x0,0x4,0x9,0xF,0xA,0x3,0x7,0xC,0xD,0x6,0xE,0x1,0xB},
	{0x0,0x1,0x7,0xD,0xB,0x4,0x5,0x2,0x8,0xE,0xF,0xC,0x9,0xA,0x6,0x3},
	{0x1,0xB,0xC,0x2,0x9,0xD,0x0,0xF,0x4,0x5,0x8,0xE,0xA,0x7,0x6,0x3}
};

gost_subst_block Gost28147_CryptoProParamSetD=
{
	{0x1,0xA,0x6,0x8,0xF,0xB,0x0,0x4,0xC,0x3,0x5,0x9,0x7,0xD,0x2,0xE},
	{0x3,0x0,0x6,0xF,0x1,0xE,0x9,0x2,0xD,0x8,0xC,0x4,0xB,0xA,0x5,0x7},
	{0x8,0x0,0xF,0x3,0x2,0x5,0xE,0xB,0x1,0xA,0x4,0x7,0xC,0x9,0xD,0x6},
	{0x0,0xC,0x8,0x9,0xD,0x2,0xA,0xB,0x7,0x3,0x6,0x5,0x4,0xE,0xF,0x1},
	{0x1,0x5,0xE,0xC,0xA,0x7,0x0,0xD,0x6,0x2,0xB,0x4,0x9,0x3,0xF,0x8},
	{0x1,0xC,0xB,0x0,0xF,0xE,0x6,0x5,0xA,0xD,0x4,0x8,0x9,0x3,0x7,0x2},
	{0xB,0x6,0x3,0x4,0xC,0xF,0xE,0x2,0x7,0xD,0x8,0x0,0x5,0xA,0x9,0x1},
	{0xF,0xC,0x2,0xA,0x6,0x4,0x5,0x0,0x7,0x9,0xE,0xD,0x1,0xB,0x8,0x3}
};

byte  cipher_buf[32];

void kboxinit(gost_ctx *c, const gost_subst_block *b) {
	int i;
	for (i = 0; i < 256; i++) {
		register word32 x;
		x = (b->k8[i>>4] <<4 | b->k7 [i &15])<<24;
		c->k87[i] = (x<<11 | x >> (32-11));
		x = (b->k6[i>>4] << 4 | b->k5 [i &15])<<16;
		c->k65[i] = (x<<11 | x>>(32-11));
		x = (b->k4[i>>4] <<4  | b->k3 [i &15])<<8;
		c->k43[i] = (x<<11 | x>>(32-11));
		x = b->k2[i>>4] <<4  | b->k1 [i &15];
		c->k21[i] = (x <<11 | x>> (32-11));
	}
}

static word32 f(gost_ctx *c,word32 x)
{ return c->k87[x>>24 & 255] | c->k65[x>>16 & 255]|
	  c->k43[x>> 8 & 255] | c->k21[x & 255];
}

void gostcrypt(gost_ctx *c, byte *inout)
{
	register word32 n1, n2;

	n1 = inout[0]|(inout[1]<<8)|(inout[2]<<16)|(inout[3]<<24);
	n2 = inout[4]|(inout[5]<<8)|(inout[6]<<16)|(inout[7]<<24);

	n2 ^= f(c,n1+c->k[0]); n1 ^= f(c,n2+c->k[1]);
	n2 ^= f(c,n1+c->k[2]); n1 ^= f(c,n2+c->k[3]);
	n2 ^= f(c,n1+c->k[4]); n1 ^= f(c,n2+c->k[5]);
	n2 ^= f(c,n1+c->k[6]); n1 ^= f(c,n2+c->k[7]);

	n2 ^= f(c,n1+c->k[0]); n1 ^= f(c,n2+c->k[1]);
	n2 ^= f(c,n1+c->k[2]); n1 ^= f(c,n2+c->k[3]);
	n2 ^= f(c,n1+c->k[4]); n1 ^= f(c,n2+c->k[5]);
	n2 ^= f(c,n1+c->k[6]); n1 ^= f(c,n2+c->k[7]);

	n2 ^= f(c,n1+c->k[0]); n1 ^= f(c,n2+c->k[1]);
	n2 ^= f(c,n1+c->k[2]); n1 ^= f(c,n2+c->k[3]);
	n2 ^= f(c,n1+c->k[4]); n1 ^= f(c,n2+c->k[5]);
	n2 ^= f(c,n1+c->k[6]); n1 ^= f(c,n2+c->k[7]);

	n2 ^= f(c,n1+c->k[7]); n1 ^= f(c,n2+c->k[6]);
	n2 ^= f(c,n1+c->k[5]); n1 ^= f(c,n2+c->k[4]);
	n2 ^= f(c,n1+c->k[3]); n1 ^= f(c,n2+c->k[2]);
	n2 ^= f(c,n1+c->k[1]); n1 ^= f(c,n2+c->k[0]);

	inout[0] = (n2 & 0x000000FF);  inout[1] = (n2 >> 8) & 0x000000FF; inout[2]=(n2 >> 16) & 0x000000FF; inout[3]=(n2 >> 24) & 0x000000FF;
	inout[4] = (n1 & 0x000000FF);  inout[5] = (n1 >> 8) & 0x000000FF; inout[6]=(n1 >> 16) & 0x000000FF; inout[7]=(n1 >> 24) & 0x000000FF;
}

void gostdecrypt(gost_ctx *c, byte *inout)
{
	register word32 n1, n2;

	n1 = inout[0]|(inout[1]<<8)|(inout[2]<<16)|(inout[3]<<24);
	n2 = inout[4]|(inout[5]<<8)|(inout[6]<<16)|(inout[7]<<24);

	n2 ^= f(c,n1+c->k[0]); n1 ^= f(c,n2+c->k[1]);
	n2 ^= f(c,n1+c->k[2]); n1 ^= f(c,n2+c->k[3]);
	n2 ^= f(c,n1+c->k[4]); n1 ^= f(c,n2+c->k[5]);
	n2 ^= f(c,n1+c->k[6]); n1 ^= f(c,n2+c->k[7]);

	n2 ^= f(c,n1+c->k[7]); n1 ^= f(c,n2+c->k[6]);
	n2 ^= f(c,n1+c->k[5]); n1 ^= f(c,n2+c->k[4]);
	n2 ^= f(c,n1+c->k[3]); n1 ^= f(c,n2+c->k[2]);
	n2 ^= f(c,n1+c->k[1]); n1 ^= f(c,n2+c->k[0]);

	n2 ^= f(c,n1+c->k[7]); n1 ^= f(c,n2+c->k[6]);
	n2 ^= f(c,n1+c->k[5]); n1 ^= f(c,n2+c->k[4]);
	n2 ^= f(c,n1+c->k[3]); n1 ^= f(c,n2+c->k[2]);
	n2 ^= f(c,n1+c->k[1]); n1 ^= f(c,n2+c->k[0]);

	n2 ^= f(c,n1+c->k[7]); n1 ^= f(c,n2+c->k[6]);
	n2 ^= f(c,n1+c->k[5]); n1 ^= f(c,n2+c->k[4]);
	n2 ^= f(c,n1+c->k[3]); n1 ^= f(c,n2+c->k[2]);
	n2 ^= f(c,n1+c->k[1]); n1 ^= f(c,n2+c->k[0]);
        inout[0] = (n2 & 0x000000FF);  inout[1] = (n2 >> 8) & 0x000000FF; inout[2]=(n2 >> 16) & 0x000000FF; inout[3]=(n2 >> 24) & 0x000000FF;
        inout[4] = (n1 & 0x000000FF);  inout[5] = (n1 >> 8) & 0x000000FF; inout[6]=(n1 >> 16) & 0x000000FF; inout[7]=(n1 >> 24) & 0x000000FF;

}

void gost_key(gost_ctx *c, const byte *k)
{
	c->k[0] = k[ 0] | (k[ 1]<<8) | (k[ 2]<<16) | (k[ 3]<<24);
	c->k[1] = k[ 4] | (k[ 5]<<8) | (k[ 6]<<16) | (k[ 7]<<24);
	c->k[2] = k[ 8] | (k[ 9]<<8) | (k[10]<<16) | (k[11]<<24);
	c->k[3] = k[12] | (k[13]<<8) | (k[14]<<16) | (k[15]<<24);
	c->k[4] = k[16] | (k[17]<<8) | (k[18]<<16) | (k[19]<<24);
	c->k[5] = k[20] | (k[21]<<8) | (k[22]<<16) | (k[23]<<24);
	c->k[6] = k[24] | (k[25]<<8) | (k[26]<<16) | (k[27]<<24);
	c->k[7] = k[28] | (k[29]<<8) | (k[30]<<16) | (k[31]<<24);
}

void gost_init(gost_ctx *c, const byte *key, const gost_subst_block *b)
{
	if(!b) {
		b=&GostR3411_94_TestParamSet;
	}
	kboxinit(c,b);
	gost_key(c, key);
}


void gost_enc_cfb(gost_ctx *c, const byte *initvector, byte *cipher_buf, int nbytes)
{
	int i, j, n, remainder;
	byte gamma[8];

	for(n = 0; n < 8; n ++)
		gamma[n] = initvector[n];
	gostcrypt(c, gamma);

	for(i = 0; nbytes-i > 8; i+=8, cipher_buf += 8)
	{
		for(j = 0; j < 8; j++)
			{
				cipher_buf[j] = cipher_buf[j] ^ gamma[j];
				gamma[j] = cipher_buf[j];
			}
		gostcrypt(c, gamma);
	}

	remainder = nbytes - i;
	for(j = 0; j < remainder; j++)
		cipher_buf[j] = cipher_buf[j] ^ gamma[j];

}

void gost_dec_cfb(gost_ctx *c, const byte *initvector, byte *cipher_buf, int nbytes)
{
	int i, j, n, remainder;
	byte gamma[8];
	byte t;

	for(n = 0; n < 8; n ++)
		gamma[n] = initvector[n];
	gostcrypt(c, gamma);

	for(i = 0; nbytes-i > 8; i+=8, cipher_buf += 8)
	{
		for(j = 0; j < 8; j++)
			{
				cipher_buf[j] = (t = cipher_buf[j]) ^ gamma[j];
				gamma[j] = t;
			}
		gostcrypt(c, gamma);
	}

	remainder = nbytes - i;
	for(j = 0; j < remainder; j++)
		cipher_buf[j] = cipher_buf[j] ^ gamma[j];
}

void init_crypt(void)
{
	byte key[32] = { 0x80,0x8,0x10,0x1,0x90,0x9,0x20,0x2,
		 0xA0,0xA,0x30,0x3,0xB0,0xB,0x40,0x4,
		 0xC0,0xC,0x50,0x5,0xD0,0xD,0x60,0x6,
		 0xE0,0xE,0x70,0x7,0xF0,0xf,0x00,0xff }; //ключ шифрования
const byte initvector[8] = { 0xA2, 0x56, 0xFD, 0x12, 0x45, 0xF1, 0xD1, 0xE5 }; //синхропосылка

byte  plaintext[] = "still use word fast write";
extern byte  cipher_buf[32];
int i;

for(i = 0; i< sizeof(plaintext); i++ )
	cipher_buf[i] = plaintext[i];

gost_ctx c;


gost_init(&c, key, &GostR3411_94_SberbankHashParamset);

gost_enc_cfb(&c, initvector, cipher_buf, 10);

}
*/
import "C"

import (
	"fmt"
)

func main() {

	var x C.int
	var arr [4]C.int
	var p_arr *C.byte
	var p_arr_2 *C.byte
	//p_arr = &arr[0]

	for i, _ := range arr {
		arr[i] = 10
	}

	C.init_crypt()

	p_arr = &C.cipher_buf[0]
	p_arr_2 = &C.cipher_buf[1]

	x = 10
	fmt.Println(x)
	fmt.Println(arr)
	fmt.Println(*p_arr, *p_arr_2)
}